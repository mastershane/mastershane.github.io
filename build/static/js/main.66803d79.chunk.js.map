{"version":3,"sources":["camel-parser.ts","camel.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["codeColorMap","hazardCodeMap","parseCamel","camelCode","tiles","toLowerCase","split","map","squareString","tile","camels","forEach","character","push","hazard","Error","parseDice","diceCode","c","color","toCamelCode","camelState","colorToCode","join","getOdds","dice","camelWins","first","second","tileHits","t","i","hits","permutations","permutation","k","p","length","result","slice","Array","fill","permute","timelines","rollGraph","addDieRolls","index","previousRolls","die","rolls","n","Roll","nextRolls","r","traverse","rollNode","clone","winners","simulateWinner","getBetValue","firstOdds","secondOdds","betValue","oddsResult","camelOdds","Object","keys","wins","camel","firstPlaceOdds","secondPlaceOdds","fiveValue","threeValue","twoValue","desertHit","oasisHits","timeLine","cloneState","roll","hitIndex","moveCamelUnit","dieRoll","tileIndex","findIndex","indexOf","camelUnit","splice","ensureTileExists","placeCamelsAtTile","destinationIndex","destinationTile","specialDestination","otherCamels","specialDestinationIndex","generateInitialState","getRandomRoll","dieIndex","Math","floor","random","rollNumber","App","useState","boardInput","diceInput","state","setState","className","onSubmit","e","results","error","undefined","console","log","calculate","preventDefault","htmlFor","type","id","spellCheck","value","onChange","target","selectedOption","parseInt","remainingDice","replace","style","marginTop","selected","disabled","d","label","role","scope","toFixed","o","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.66803d79.chunk.js","sourcesContent":["// convert camel code into the camel state data model\r\n\r\nimport { CamelState, Color, Die, Hazard, Map, Tile } from \"./camel\";\r\n\r\nconst codeColorMap: Map<Color> = {\r\n    \"r\": \"Red\",\r\n    \"b\": \"Blue\",\r\n    \"g\": \"Green\",\r\n    \"y\": \"Yellow\",\r\n    \"w\": \"White\",\r\n};\r\nconst hazardCodeMap: Map<Hazard> = {\r\n    \"o\":\"Oasis\",\r\n    \"d\": \"Desert\"\r\n};\r\n\r\nexport const parseCamel = (camelCode: string): CamelState => {\r\n    const tiles = camelCode.toLowerCase().split(\",\").map(squareString => {\r\n        const tile:Tile = {camels: []};\r\n        squareString.split('').forEach(character => {\r\n            switch(character) {\r\n                case \"r\":\r\n                case \"b\":\r\n                case \"g\":\r\n                case \"y\":\r\n                case \"w\":\r\n                    tile.camels.push(codeColorMap[character]);\r\n                    break;\r\n                case \"o\":\r\n                case \"d\":\r\n                    tile.hazard = hazardCodeMap[character];\r\n                    break;\r\n                default:\r\n                    throw new Error(`Unsupported Character ${character} found in camel string`)\r\n            }\r\n        });\r\n        return tile;\r\n    });\r\n    return { tiles };\r\n};\r\n\r\nexport const parseDice = (diceCode: string): Die[] => {\r\n    return diceCode.split(\"\").map(c => ({ color: codeColorMap[c] }));\r\n};\r\n\r\nexport const toCamelCode = (camelState: CamelState): string => {\r\n    \r\n    return camelState.tiles.map(tile => {\r\n        if(tile.hazard){\r\n            switch(tile.hazard){\r\n                case 'Oasis':\r\n                    return 'o';\r\n                case 'Desert':\r\n                    return 'd';\r\n            }\r\n        }\r\n        return tile.camels.map(colorToCode).join('');\r\n    }).join(',');\r\n}\r\n\r\nexport const toDiceCode = (dice: Die[]) => {\r\n    return dice.map(d => colorToCode(d.color)).join('');\r\n};\r\n\r\nexport const colorToCode = (color: Color) => {\r\n    switch(color) {\r\n        case 'Red':\r\n            return 'r';\r\n        case 'Green':\r\n            return 'g';\r\n        case 'Blue': \r\n            return 'b';\r\n        case 'White':\r\n            return 'w';\r\n        case 'Yellow':\r\n            return 'y';\r\n    }\r\n};\r\n","\r\nexport type Color = 'Red' | 'Blue' | 'Green' | 'White' | 'Yellow';\r\nexport type Roll = 1 | 2 | 3;\r\nexport type Hazard = 'Desert' | 'Oasis';\r\n\r\n// tslint:disable: interface-name\r\nexport interface Camel {\r\n\tcolor: Color;\r\n}\r\n\r\nexport interface Tile {\r\n\tcamels: Color[];\r\n    hazard?: Hazard;\r\n}\r\n\r\nexport interface CamelState {\r\n\ttiles: Tile[];\r\n}\r\n\r\nexport interface CamelOdds {\r\n\tcamel: Color;\r\n\tfirstPlaceOdds: number;\r\n\tsecondPlaceOdds: number;\r\n\tfiveValue: number;\r\n\tthreeValue: number;\r\n\ttwoValue: number;\r\n}\r\n\r\nexport interface Die {\r\n\tcolor: Color;\r\n}\r\n\r\nexport interface DieRoll extends Die {\r\n\tRoll: Roll;\r\n}\r\n\r\nexport interface Map<T> {\r\n\t[K: string]: T;\r\n}\r\n\r\nexport interface OddsResult {\r\n\tcamelOdds: CamelOdds[];\r\n\tdesertHit: number[];\r\n\toasisHits: number[];\r\n}\r\n\r\ninterface TileHits {\r\n\ttile: Tile,\r\n\thits: number,\r\n}\r\n\r\n// lets just calculate every outcome and get the odds of each\r\nexport const getOdds = (camelState: CamelState, dice: Die[]): OddsResult => {\r\n\r\n\tconst camelWins: Map<{first: number, second: number}> = {\r\n\t\t'Red': {first: 0, second: 0},\r\n\t\t'Blue': {first: 0, second: 0},\r\n\t\t'Green': {first: 0, second: 0},\r\n\t\t'White': {first: 0, second: 0},\r\n\t\t'Yellow': {first: 0, second: 0},\r\n\t};\r\n\r\n\tconst tileHits = camelState.tiles.map((t, i) => ({tile: t, hits: 0}));\r\n\r\n\t// having all possible timelines in memory at once may be a burdon - look into streaming.\r\n\tconst permutations = permute(dice);\r\n\tconst timelines: DieRoll[][] = [];\r\n\r\n\t// populate all timelines\r\n\tpermutations.forEach((permutation) => {\r\n\t\tinterface RollNode extends DieRoll {\r\n\t\t\tnextRolls: RollNode[];\r\n\t\t}\r\n\t\tconst addDieRolls = (index: number, previousRolls?: RollNode[]) => {\r\n\t\t\tif (index >= permutation.length) {\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\r\n\t\t\tconst die = permutation[index];\r\n\t\t\tconst rollValues: Roll[] = [\r\n\t\t\t\t1, 2, 3,\r\n\t\t\t];\r\n\t\t\t\r\n\t\t\tconst rolls: RollNode[] = rollValues.map((n: Roll) => ({\t\t\t\t\r\n\t\t\t\tcolor: die.color,\r\n\t\t\t\tRoll: n,\r\n\t\t\t\tnextRolls: [],\r\n\t\t\t}));\r\n\r\n\t\t\t// graph will use references fyi, hopefully wont be an issue\r\n\t\t\tif (previousRolls) { \r\n\t\t\t\tpreviousRolls.forEach((r) => r.nextRolls = rolls);\r\n\t\t\t}\r\n\t\t\taddDieRolls(index + 1, rolls);\r\n\t\t\treturn rolls;\r\n\t\t};\r\n\t\tconst rollGraph = addDieRolls(0);\r\n\t\tconst traverse = (rollNode: RollNode, rolls: DieRoll[]) => {\r\n\t\t\tconst clone = [...rolls];\r\n\t\t\tclone.push(rollNode);\r\n\t\t\tif (rollNode.nextRolls.length) {\r\n\t\t\t\trollNode.nextRolls.forEach((r) => {\r\n\t\t\t\t\ttraverse(r, clone);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\ttimelines.push(clone);\r\n\t\t\t}\r\n\t\t};\r\n\t\trollGraph.forEach((n) => traverse(n, []));\t\t\r\n\t});\r\n\r\n\ttimelines.forEach((t) => {\r\n\t\tconst winners = simulateWinner(camelState, t);\r\n\r\n\t\tcamelWins[winners.first].first = camelWins[winners.first].first + 1;\r\n\t\tcamelWins[winners.second].second = camelWins[winners.second].second + 1;\r\n\t\twinners.tileHits.forEach((t, i) => {\r\n\t\t\ttileHits[i].hits = tileHits[i].hits + t.hits;\r\n\t\t})\r\n\t});\r\n\r\n\tconst getBetValue = (firstOdds: number, secondOdds: number, betValue: number) => {\r\n\t\tconst loseOdds = 1 - (firstOdds + secondOdds);\r\n\t\treturn (firstOdds * betValue) + (secondOdds * 1) + (loseOdds * -1);\r\n\t};\r\n\r\n\tconst oddsResult: OddsResult =  {\r\n\t\tcamelOdds: \tObject.keys(camelWins).map((k) => {\r\n\t\t\tconst wins = camelWins[k];\r\n\t\t\tconst firstOdds = wins.first / timelines.length;\r\n\t\t\tconst secondOdds = wins.second / timelines.length;\r\n\t\t\tconst camelOdds: CamelOdds = {\r\n\t\t\t\tcamel: k as Color,\r\n\t\t\t\tfirstPlaceOdds: firstOdds,\r\n\t\t\t\tsecondPlaceOdds: secondOdds,\r\n\t\t\t\tfiveValue: getBetValue(firstOdds, secondOdds, 5),\r\n\t\t\t\tthreeValue: getBetValue(firstOdds, secondOdds, 3),\r\n\t\t\t\ttwoValue: getBetValue(firstOdds, secondOdds, 2),\r\n\t\t\t};\r\n\t\r\n\t\t\treturn camelOdds;\r\n\t\t}),\r\n\t\tdesertHit: [],\r\n\t\toasisHits: [],\t\t\r\n\t};\r\n\ttileHits.forEach(t => {\r\n\t\tif(t.tile.hazard){\r\n\t\t\tswitch(t.tile.hazard){\r\n\t\t\t\tcase 'Desert':\r\n\t\t\t\t\toddsResult.desertHit.push(t.hits / timelines.length);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'Oasis':\r\n\t\t\t\t\toddsResult.oasisHits.push(t.hits / timelines.length);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\treturn oddsResult;\r\n\r\n};\r\n\r\nexport const simulateWinner = (camelState: CamelState, timeLine: DieRoll[]): {\r\n\tfirst: Color, second: Color, tileHits: TileHits[] \r\n}  => {\r\n\tconst cloneState: CamelState = {\r\n\t\ttiles: [...camelState.tiles.map((t) => ({camels: [...t.camels], hazard: t.hazard}))],\r\n\t};\r\n\r\n\tconst tileHits = camelState.tiles.map((t, i) => ({tile: t, hits: 0}));\r\n\t// update the state after each die roll in the timeline\r\n\ttimeLine.forEach((roll) => {\r\n\r\n\t\tconst hitIndex = moveCamelUnit(cloneState, roll);\r\n\t\tif(hitIndex < tileHits.length){\r\n\t\t\ttileHits[hitIndex].hits++;\r\n\t\t}\r\n\t});\r\n\r\n\tconst winners: Color[] = [];\r\n\r\n\t// get the end of round first and second place camel\r\n\tfor (let t = cloneState.tiles.length - 1; t >= 0; t--) {\r\n\t\tconst tile = cloneState.tiles[t];\r\n\t\tfor (let c = tile.camels.length - 1; c >= 0; c--) {\r\n\t\t\twinners.push(tile.camels[c]);\r\n\t\t\tif (winners.length === 2) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tfirst: winners[0], \r\n\t\t\t\t\tsecond: winners[1],\r\n\t\t\t\t\ttileHits,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tthrow Error('this code should not be reached');\r\n};\r\n\r\n// update the camel state based on the DieRoll\r\n// returns the destination index ignoring the special hazard movement\r\nexport const moveCamelUnit = (camelState: CamelState, dieRoll: DieRoll): number => {\r\n\tconst tileIndex = camelState.tiles.findIndex((t) => t.camels.indexOf(dieRoll.color) > -1);\r\n\tconst tile = camelState.tiles[tileIndex];\r\n\r\n\t// getting and removing the camel unit\r\n\tconst camelUnit = tile.camels.splice(tile.camels.indexOf(dieRoll.color));\r\n\r\n\tconst ensureTileExists = (index: number) => {\r\n\t\tif (index >= camelState.tiles.length) {\r\n\t\t\tfor (let i = camelState.tiles.length - 1; i < index; i++) {\r\n\t\t\t\tcamelState.tiles.push({camels: []});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconst placeCamelsAtTile = (camels: Color[], tile: Tile) => {\r\n\t\tcamels.forEach((c) => {\r\n\t\t\ttile.camels.push(c);\r\n\t\t});\r\n\t}\r\n\r\n\tconst destinationIndex = tileIndex + dieRoll.Roll;\r\n\r\n\t// make sure that tiles in front exist in the array\r\n\tensureTileExists(destinationIndex)\r\n\r\n\tconst destinationTile = camelState.tiles[destinationIndex];\r\n\tif(destinationTile.hazard === 'Desert'){\r\n\t\tconst specialDestination = camelState.tiles[destinationIndex - 1];\r\n\r\n\t\t// make sure that the moving camel unit is placed under the other camels\r\n\t\tconst otherCamels = specialDestination.camels;\r\n\t\tspecialDestination.camels = [];\r\n\t\t\r\n\t\tplaceCamelsAtTile(camelUnit, specialDestination);\r\n\t\tplaceCamelsAtTile(otherCamels, specialDestination);\r\n\r\n\t} else if(destinationTile.hazard === 'Oasis'){\r\n\t\tconst specialDestinationIndex = destinationIndex + 1;\r\n\t\tensureTileExists(specialDestinationIndex);\r\n\t\t\r\n\t\tconst specialDestination = camelState.tiles[specialDestinationIndex];\r\n\t\tplaceCamelsAtTile(camelUnit, specialDestination);\r\n\r\n\t} else {\r\n\t\tplaceCamelsAtTile(camelUnit, destinationTile);\r\n\t}\r\n\treturn destinationIndex;\r\n};\r\n\r\nexport const generateInitialState = (): CamelState => {\r\n\tconst dice: Die[] = [{color:'Red'}, {color:'Green'},{color:'White'},{color:'Blue'},{color:'Yellow'}];\r\n\r\n\tconst camelState: CamelState = {tiles:[{camels: []}, {camels: []}, {camels: []}]};\r\n\twhile(dice.length) {\r\n\t\tconst dieRoll = getRandomRoll(dice);\r\n\t\tcamelState.tiles[dieRoll.Roll - 1].camels.push(dieRoll.color);\r\n\t}\r\n\treturn camelState;\r\n};\r\n\r\n// note: this will actually modify the dice array in the parameter\r\nexport const getRandomRoll = (dice: Die[]): DieRoll => {\r\n\r\n\tconst dieIndex = Math.floor(Math.random() * (dice.length));\r\n\tconst die = dice.splice(dieIndex, 1)[0];\r\n\tconst rollNumber = Math.floor(Math.random() * 3) + 1\r\n\r\n\treturn {...die, Roll: rollNumber as Roll};\r\n};\r\n\r\n// creates returns every possible permutation of an array\r\nfunction permute<T>(permutation: T[]): T[][] {\r\n\tconst length = permutation.length;\r\n\tconst result = [permutation.slice()];\r\n\tconst c = new Array(length).fill(0);\r\n\tlet i = 1;\r\n\tlet k;\r\n\tlet p;\r\n  \r\n\twhile (i < length) {\r\n\t  if (c[i] < i) {\r\n\t\tk = i % 2 && c[i];\r\n\t\tp = permutation[i];\r\n\t\tpermutation[i] = permutation[k];\r\n\t\tpermutation[k] = p;\r\n\t\t++c[i];\r\n\t\ti = 1;\r\n\t\tresult.push(permutation.slice());\r\n\t  } else {\r\n\t\tc[i] = 0;\r\n\t\t++i;\r\n\t  }\r\n\t}\r\n\treturn result;\r\n  }\r\n","import React, { useState } from 'react';\r\nimport './App.css';\r\nimport { colorToCode, parseCamel, parseDice, toCamelCode } from './camel-parser'\r\nimport { Color, DieRoll, generateInitialState, getOdds, moveCamelUnit, OddsResult, Roll } from './camel'\r\n\r\ninterface IState {\r\n  boardInput: string;\r\n  diceInput: string;\r\n  results?: OddsResult;\r\n  error?: string;\r\n}\r\nfunction App() {\r\n\r\n  // create a random initial state will all dice remaining\r\n  const [state, setState] = useState<IState>({ \r\n    boardInput: toCamelCode(generateInitialState()), \r\n    diceInput: \"rgbyw\" \r\n  });\r\n\r\n  const calculate = () => {\r\n    try {\r\n      const camelState = parseCamel(state.boardInput);\r\n      const dice = parseDice(state.diceInput);\r\n      const results = getOdds(camelState, dice);\r\n      setState({...state, results, error: undefined})\r\n    } catch (e) {\r\n      setState({...state, error: 'Error made during calculation'});\r\n      console.log(e);\r\n    }\r\n  };\r\n\r\n  const selectNextRoll = (e: any) => {\r\n    try {\r\n      // option format is Color_Roll e.g. Red_1\r\n      const selectedOption = e.target.value.split('_');\r\n      const color = selectedOption[0] as Color;\r\n      const dieRoll: DieRoll = {\r\n        color: color,\r\n        Roll: parseInt(selectedOption[1]) as Roll,\r\n      }\r\n      const camelState = parseCamel(state.boardInput);\r\n      moveCamelUnit(camelState, dieRoll);\r\n\r\n      let remainingDice = state.diceInput.replace(colorToCode(color), '');\r\n      \r\n      // if there are no remaining dice. Move to next round and clear the board;\r\n      if(!remainingDice){\r\n        remainingDice = 'rwgby';\r\n        camelState.tiles.forEach(t => t.hazard = undefined);\r\n      }\r\n\r\n      const dice = parseDice(remainingDice);\r\n      const results = getOdds(camelState, dice);\r\n      setState({boardInput: toCamelCode(camelState), diceInput: remainingDice, results});\r\n\r\n    } catch(e) {\r\n      setState({...state, error: 'Error made during calculation'});\r\n      console.log(e);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"container\">\r\n      <h1>Cameluculator</h1>\r\n      <p>Enter a game state using camel code. Separate spaces with a \",\". Camels stack so that the right most camel will be on top. Example: rw,,o,gby</p>\r\n      <h3>Key:</h3>\r\n      <ul>\r\n        <li>r: Red Camel</li>\r\n        <li>g: Green Camel</li>\r\n        <li>w: White Camel</li>\r\n        <li>b: Blue Camel</li>\r\n        <li>y: Yellow Camel</li>\r\n        <li>d: Desert</li>\r\n        <li>o: Oasis</li>\r\n      </ul>\r\n      <form onSubmit={(e) => {calculate(); e.preventDefault();}}>\r\n        <div className=\"form-group\">\r\n          <label className=\"form-label\" htmlFor=\"camel-code\">Camel Code </label>\r\n          <input className=\"form-control\" type=\"text\" id=\"camel-code\" spellCheck=\"false\" value={state.boardInput} onChange={(e) => setState({...state, boardInput: e.target.value})} />\r\n        </div>\r\n        <div className=\"form-group\">  \r\n          <label htmlFor=\"dice\">Remaining Dice </label>\r\n          <input className=\"form-control\" type=\"text\" id=\"dice\" spellCheck=\"false\" value={state.diceInput} onChange={(e) => setState({...state, diceInput: e.target.value})} /> \r\n        </div>\r\n        <br />\r\n        <input className=\"btn btn-primary\" type=\"submit\" value=\"Calculate!\"/>\r\n        {state.results && \r\n          <select className=\"form-select\" onChange={selectNextRoll} value='_' style={{marginTop: '10px'}}>\r\n            <option selected disabled value='_'>Select Next Roll</option>\r\n            {parseDice(state.diceInput).map(d =>\r\n              <optgroup label={d.color}>\r\n                <option value={d.color + '_1'}>{d.color + ' 1'}</option>\r\n                <option value={d.color + '_2'}>{d.color + ' 2'}</option>\r\n                <option value={d.color + '_3'}>{d.color + ' 3'}</option>\r\n              </optgroup>\r\n            )}\r\n          </select>\r\n        }\r\n      </form>\r\n      <br />\r\n      {state.error && \r\n        <div className=\"alert alert-danger\" role=\"alert\">\r\n          {state.error}\r\n        </div>\r\n      }\r\n      {state.results && <>\r\n        <table className=\"table table-bordered\">\r\n          <thead>\r\n            <tr>\r\n              <th>Camel</th>\r\n              <th>Five Value</th>\r\n              <th>Three Value</th>\r\n              <th>Two Value</th>\r\n              <th>First Place Odds</th>\r\n              <th>Second Place Odds</th>\r\n            </tr>\r\n          </thead>\r\n          <tbody>\r\n            {state.results.camelOdds.map(r => \r\n                <tr key={r.camel}>\r\n                <th scope=\"row\">{r.camel}</th>\r\n                <td>{+r.fiveValue.toFixed(3)}</td>\r\n                <td>{+r.threeValue.toFixed(3)}</td>\r\n                <td>{+r.twoValue.toFixed(3)}</td>\r\n                <td>{+r.firstPlaceOdds.toFixed(3)}</td>\r\n                <td>{+r.secondPlaceOdds.toFixed(3)}</td>\r\n              </tr>\r\n            )}\r\n          </tbody>\r\n        </table>\r\n        {state.results.desertHit.map((d, i) => \r\n          <div>Desert {i + 1} value: {+d.toFixed(3)}</div>\r\n        )}\r\n        {state.results.oasisHits.map((o, i) => \r\n          <div>Oasis {i + 1} value: {+o.toFixed(3)}</div>\r\n        )}\r\n      </>}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);  \r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n}\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport 'bootstrap/dist/css/bootstrap.css';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}