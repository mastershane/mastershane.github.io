{"version":3,"sources":["camel-parser.ts","camel.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["codeColorMap","getOdds","camelState","dice","camelWins","first","second","permutations","permutation","k","p","length","result","slice","c","Array","fill","i","push","permute","timelines","forEach","rollGraph","addDieRolls","index","previousRolls","die","rolls","map","n","color","Roll","nextRolls","r","traverse","rollNode","clone","t","winners","simulateWinner","getBetValue","firstOdds","secondOdds","betValue","Object","keys","wins","camel","firstPlaceOdds","secondPlaceOdds","fiveValue","threeValue","twoValue","timeLine","tiles","camels","roll","dieRoll","tileIndex","findIndex","indexOf","tile","camelUnit","splice","destinationIndex","moveCamelUnit","Error","App","useState","boardInput","diceInput","state","setState","calculate","split","squareString","character","results","className","onSubmit","e","preventDefault","type","value","onChange","target","toFixed","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f2b2d791.chunk.js","sourcesContent":["// convert camel code into the camel state data model\r\n\r\nimport { CamelState, Color, Die, Map, Tile } from \"./camel\";\r\n\r\nconst codeColorMap: Map<Color> = {\r\n    \"r\": \"Red\",\r\n    \"b\": \"Blue\",\r\n    \"g\": \"Green\",\r\n    \"y\": \"Yellow\",\r\n    \"w\": \"White\",\r\n}\r\n\r\nexport const parseCamel = (camelCode: string): CamelState => {\r\n    const tiles = camelCode.split(\",\").map(squareString => {\r\n        const tile:Tile = {camels: []};\r\n        squareString.split('').forEach(character => {\r\n            switch(character) {\r\n                case \"r\":\r\n                case \"b\":\r\n                case \"g\":\r\n                case \"y\":\r\n                case \"w\":\r\n                    tile.camels.push(codeColorMap[character]);\r\n                    break;\r\n                default:\r\n                    throw new Error(`Unsupported Character ${character} found in camel string`)\r\n            }\r\n        });\r\n        return tile;\r\n    });\r\n    return { tiles };\r\n};\r\n\r\nexport const parseDice = (diceCode: string): Die[] => {\r\n    return diceCode.split(\"\").map(c => ({ color: codeColorMap[c] }));\r\n};\r\n","\r\nexport type Color = 'Red' | 'Blue' | 'Green' | 'White' | 'Yellow';\r\nexport type Roll = 1 | 2 | 3;\r\n// tslint:disable: interface-name\r\nexport interface Camel {\r\n\tcolor: Color;\r\n}\r\n\r\nexport interface Tile {\r\n\tcamels: Color[];\r\n}\r\n\r\nexport interface CamelState {\r\n\ttiles: Tile[];\r\n}\r\n\r\nexport interface CamelOdds {\r\n\tcamel: Color;\r\n\tfirstPlaceOdds: number;\r\n\tsecondPlaceOdds: number;\r\n\tfiveValue: number;\r\n\tthreeValue: number;\r\n\ttwoValue: number;\r\n}\r\n\r\nexport interface Die {\r\n\tcolor: Color;\r\n}\r\n\r\nexport interface DieRoll extends Die {\r\n\tRoll: Roll;\r\n}\r\n\r\nexport interface Map<T> {\r\n\t[K: string]: T;\r\n}\r\n\r\n// lets just calculate every outcome and get the odds of each\r\nexport const getOdds = (camelState: CamelState, dice: Die[]): CamelOdds[] => {\r\n\r\n\tconst camelWins: Map<{first: number, second: number}> = {\r\n\t\t'Red': {first: 0, second: 0},\r\n\t\t'Blue': {first: 0, second: 0},\r\n\t\t'Green': {first: 0, second: 0},\r\n\t\t'White': {first: 0, second: 0},\r\n\t\t'Yellow': {first: 0, second: 0},\r\n\t};\r\n\r\n\t// having all possible timelines in memory at once may be a burdon - look into streaming.\r\n\tconst permutations = permute(dice);\r\n\tconst timelines: DieRoll[][] = [];\r\n\r\n\t// populate all timelines\r\n\tpermutations.forEach((permutation) => {\r\n\t\tinterface RollNode extends DieRoll {\r\n\t\t\tnextRolls: RollNode[];\r\n\t\t}\r\n\t\tconst addDieRolls = (index: number, previousRolls?: RollNode[]) => {\r\n\t\t\tif (index >= permutation.length) {\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\r\n\t\t\tconst die = permutation[index];\r\n\t\t\tconst rollValues: Roll[] = [\r\n\t\t\t\t1 , 2, 3,\r\n\t\t\t];\r\n\t\t\t\r\n\t\t\tconst rolls: RollNode[] = rollValues.map((n: Roll) => ({\t\t\t\t\r\n\t\t\t\tcolor: die.color,\r\n\t\t\t\tRoll: n,\r\n\t\t\t\tnextRolls: [],\r\n\t\t\t}));\r\n\r\n\t\t\t// graph will use references fyi, hopefully wont be an issue\r\n\t\t\tif (previousRolls) { \r\n\t\t\t\tpreviousRolls.forEach((r) => r.nextRolls = rolls);\r\n\t\t\t}\r\n\t\t\taddDieRolls(index + 1, rolls);\r\n\t\t\treturn rolls;\r\n\t\t};\r\n\t\tconst rollGraph = addDieRolls(0);\r\n\t\tconst traverse = (rollNode: RollNode, rolls: DieRoll[]) => {\r\n\t\t\tconst clone = [...rolls];\r\n\t\t\tclone.push(rollNode);\r\n\t\t\tif (rollNode.nextRolls.length) {\r\n\t\t\t\trollNode.nextRolls.forEach((r) => {\r\n\t\t\t\t\ttraverse(r, clone);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\ttimelines.push(clone);\r\n\t\t\t}\r\n\t\t};\r\n\t\trollGraph.forEach((n) => traverse(n, []));\t\t\r\n\t});\r\n\r\n\ttimelines.forEach((t) => {\r\n\t\tconst winners = simulateWinner(camelState, t);\r\n\r\n\t\tcamelWins[winners.first].first = camelWins[winners.first].first + 1;\r\n\t\tcamelWins[winners.second].second = camelWins[winners.second].second + 1;\r\n\t});\r\n\r\n\tconst getBetValue = (firstOdds: number, secondOdds: number, betValue: number) => {\r\n\t\tconst loseOdds = 1 - (firstOdds + secondOdds);\r\n\t\treturn (firstOdds * betValue) + (secondOdds * 1) + (loseOdds * -1);\r\n\t};\r\n\r\n\treturn Object.keys(camelWins).map((k) => {\r\n\t\tconst wins = camelWins[k];\r\n\t\tconst firstOdds = wins.first / timelines.length;\r\n\t\tconst secondOdds = wins.second / timelines.length;\r\n\t\tconst camelOdds: CamelOdds = {\r\n\t\t\tcamel: k as Color,\r\n\t\t\tfirstPlaceOdds: firstOdds,\r\n\t\t\tsecondPlaceOdds: secondOdds,\r\n\t\t\tfiveValue: getBetValue(firstOdds, secondOdds, 5),\r\n\t\t\tthreeValue: getBetValue(firstOdds, secondOdds, 3),\r\n\t\t\ttwoValue: getBetValue(firstOdds, secondOdds, 2),\r\n\t\t} ;\r\n\t\treturn camelOdds;\r\n\t});\r\n};\r\n\r\n// need to account for deserts and stuff like that on the camel state\r\nexport const simulateWinner = (camelState: CamelState, timeLine: DieRoll[]): {first: Color, second: Color }  => {\r\n\tconst clone: CamelState = {\r\n\t\ttiles: [...camelState.tiles.map((t) => ({camels: [...t.camels]}))],\r\n\t};\r\n\r\n\tconst moveCamelUnit = (dieRoll: DieRoll) => {\r\n\t\tconst tileIndex = clone.tiles.findIndex((t) => t.camels.indexOf(dieRoll.color) > -1);\r\n\t\tconst tile = clone.tiles[tileIndex];\r\n\r\n\t\t// getting and removing the camel unit\r\n\t\tconst camelUnit = tile.camels.splice(tile.camels.indexOf(dieRoll.color));\r\n\r\n\t\tconst destinationIndex = tileIndex + dieRoll.Roll;\r\n\r\n\t\t// making sure that tiles in front exist in the array\r\n\t\tif (destinationIndex >= clone.tiles.length) {\r\n\t\t\tfor (let i = clone.tiles.length - 1; i < destinationIndex; i++) {\r\n\t\t\t\tclone.tiles.push({camels: []});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// move each camel in the unit (preserving vertical order)\r\n\t\tcamelUnit.forEach((c) => {\r\n\t\t\tclone.tiles[destinationIndex].camels.push(c);\r\n\t\t});\t\t\r\n\t};\r\n\r\n\ttimeLine.forEach((roll) => {\r\n\t\tmoveCamelUnit(roll);\r\n\t});\r\n\r\n\tconst winners: Color[] = [];\r\n\r\n\tfor (let t = clone.tiles.length - 1; t >= 0; t--) {\r\n\t\tconst tile = clone.tiles[t];\r\n\t\tfor (let c = tile.camels.length - 1; c >= 0; c--) {\r\n\t\t\twinners.push(tile.camels[c]);\r\n\t\t\tif (winners.length === 2) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tfirst: winners[0], \r\n\t\t\t\t\tsecond: winners[1],\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tthrow Error('this code should not be reached');\r\n};\r\n\r\nfunction permute<T>(permutation: T[]) {\r\n\tconst length = permutation.length;\r\n\tconst result = [permutation.slice()];\r\n\tconst c = new Array(length).fill(0);\r\n\tlet i = 1;\r\n\tlet k;\r\n\tlet p;\r\n  \r\n\twhile (i < length) {\r\n\t  if (c[i] < i) {\r\n\t\tk = i % 2 && c[i];\r\n\t\tp = permutation[i];\r\n\t\tpermutation[i] = permutation[k];\r\n\t\tpermutation[k] = p;\r\n\t\t++c[i];\r\n\t\ti = 1;\r\n\t\tresult.push(permutation.slice());\r\n\t  } else {\r\n\t\tc[i] = 0;\r\n\t\t++i;\r\n\t  }\r\n\t}\r\n\treturn result;\r\n  }\r\n\r\nconst sampleCamelState: CamelState = {\r\n\ttiles: [\r\n\t\t{camels: ['Blue']},\r\n\t\t{camels: ['Red', 'Green']},\r\n\t\t{camels: ['Yellow', 'White']},\r\n\t],\r\n};\r\n\r\nexport const testOdds = () => {\r\n\tconst oddsResult = getOdds(sampleCamelState, [\r\n\t\t{color: 'Green'}, \r\n\t\t{color: 'White'}, \r\n\t\t{color: 'Red'}, \r\n\t\t{color: 'Blue'}, \r\n\t\t{color: 'Yellow'},\r\n\t]);\r\n\tconst output = JSON.stringify(oddsResult, null, '\\t');\r\n\t// tslint:disable-next-line: no-console\r\n\tconsole.log(output);\r\n};\r\n\r\n","import React, { useState } from 'react';\r\nimport './App.css';\r\nimport { parseCamel, parseDice } from './camel-parser'\r\nimport { CamelOdds, getOdds } from './camel'\r\n\r\ninterface IState {\r\n  boardInput: string;\r\n  diceInput: string;\r\n  results?: CamelOdds[];\r\n}\r\nfunction App() {\r\n\r\n  const [state, setState] = useState<IState>({ boardInput: \"\", diceInput: \"rgbyw\" });\r\n\r\n  const calculate = () => {\r\n    const camelState = parseCamel(state.boardInput);\r\n    const dice = parseDice(state.diceInput);\r\n    const results = getOdds(camelState, dice);\r\n    setState({...state, results})\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <h1>Cameluculator</h1>\r\n      <p>Enter a game state using camel code. Separate spaces with a \",\" and camels stack so that the right most camel will be on top.</p>\r\n      <h3>Key:</h3>\r\n      <ul>\r\n        <li>r: Red Camel</li>\r\n        <li>g: Green Camel</li>\r\n        <li>w: White Camel</li>\r\n        <li>b: Blue Camel</li>\r\n        <li>y: Yellow Camel</li>\r\n        {/* <li>d: Desert</li>\r\n        <li>o: Oasis</li> */}\r\n      </ul>\r\n      <form onSubmit={(e) => {calculate(); e.preventDefault();}}>\r\n        <label>\r\n          Camel Code\r\n          <input type=\"text\" value={state.boardInput} onChange={(e) => setState({...state, boardInput: e.target.value})} />\r\n        </label>\r\n        <br />\r\n        <label>\r\n          Remaining Dice\r\n          <input type=\"text\" value={state.diceInput} onChange={(e) => setState({...state, diceInput: e.target.value})} />\r\n        </label>\r\n        <br />\r\n        <input type=\"submit\" value=\"Calculate!\"/>\r\n        {state.results &&\r\n          <table>\r\n            <tr>\r\n              <th>Camel</th>\r\n              <th>Five Value</th>\r\n              <th>Three Value</th>\r\n              <th>Two Value</th>\r\n              <th>First Place Odds</th>\r\n              <th>Second Place Odds</th>\r\n            </tr>\r\n            {state.results.map(r => \r\n               <tr>\r\n                <td>{r.camel}</td>\r\n                <td>{r.fiveValue.toFixed(3)}</td>\r\n                <td>{r.threeValue.toFixed(3)}</td>\r\n                <td>{r.twoValue.toFixed(3)}</td>\r\n                <td>{r.firstPlaceOdds.toFixed(3)}</td>\r\n                <td>{r.secondPlaceOdds.toFixed(3)}</td>\r\n              </tr>\r\n            )}\r\n          </table>\r\n        }\r\n      </form>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);  \r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n}\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}