{"version":3,"sources":["camel-parser.ts","camel.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["codeColorMap","hazardCodeMap","parseCamel","camelCode","tiles","toLowerCase","split","map","squareString","tile","camels","forEach","character","push","hazard","Error","parseDice","diceCode","c","color","toCamelCode","camelState","colorToCode","join","getOdds","dice","camelWins","first","second","permutations","permutation","k","p","length","result","slice","Array","fill","i","permute","timelines","rollGraph","addDieRolls","index","previousRolls","die","rolls","n","Roll","nextRolls","r","traverse","rollNode","clone","t","winners","simulateWinner","getBetValue","firstOdds","secondOdds","betValue","Object","keys","wins","camel","firstPlaceOdds","secondPlaceOdds","fiveValue","threeValue","twoValue","timeLine","cloneState","roll","moveCamelUnit","dieRoll","tileIndex","findIndex","indexOf","camelUnit","splice","ensureTileExists","placeCamelsAtTile","destinationIndex","destinationTile","specialDestination","otherCamels","specialDestinationIndex","generateInitialState","getRandomRoll","dieIndex","Math","floor","random","rollNumber","App","useState","boardInput","diceInput","state","setState","className","onSubmit","e","results","calculate","preventDefault","htmlFor","type","id","spellCheck","value","onChange","target","selectedOption","parseInt","remainingDice","replace","undefined","style","marginTop","selected","disabled","d","label","scope","toFixed","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"uPAIMA,G,MAA2B,CAC7B,EAAK,MACL,EAAK,OACL,EAAK,QACL,EAAK,SACL,EAAK,UAEHC,EAA6B,CAC/B,EAAI,QACJ,EAAK,UAGIC,EAAa,SAACC,GAsBvB,MAAO,CAAEC,MArBKD,EAAUE,cAAcC,MAAM,KAAKC,KAAI,SAAAC,GACjD,IAAMC,EAAY,CAACC,OAAQ,IAkB3B,OAjBAF,EAAaF,MAAM,IAAIK,SAAQ,SAAAC,GAC3B,OAAOA,GACH,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACDH,EAAKC,OAAOG,KAAKb,EAAaY,IAC9B,MACJ,IAAK,IACL,IAAK,IACDH,EAAKK,OAASb,EAAcW,GAC5B,MACJ,QACI,MAAM,IAAIG,MAAJ,gCAAmCH,EAAnC,+BAGXH,OAKFO,EAAY,SAACC,GACtB,OAAOA,EAASX,MAAM,IAAIC,KAAI,SAAAW,GAAC,MAAK,CAAEC,MAAOnB,EAAakB,QAGjDE,EAAc,SAACC,GAExB,OAAOA,EAAWjB,MAAMG,KAAI,SAAAE,GACxB,GAAGA,EAAKK,OACJ,OAAOL,EAAKK,QACR,IAAK,QACD,MAAO,IACX,IAAK,SACD,MAAO,IAGnB,OAAOL,EAAKC,OAAOH,IAAIe,GAAaC,KAAK,OAC1CA,KAAK,MAOCD,EAAc,SAACH,GACxB,OAAOA,GACH,IAAK,MACD,MAAO,IACX,IAAK,QACD,MAAO,IACX,IAAK,OACD,MAAO,IACX,IAAK,QACD,MAAO,IACX,IAAK,SACD,MAAO,M,OClCNK,EAAU,SAACH,EAAwBI,GAE/C,IAAMC,EAAkD,CACvD,IAAO,CAACC,MAAO,EAAGC,OAAQ,GAC1B,KAAQ,CAACD,MAAO,EAAGC,OAAQ,GAC3B,MAAS,CAACD,MAAO,EAAGC,OAAQ,GAC5B,MAAS,CAACD,MAAO,EAAGC,OAAQ,GAC5B,OAAU,CAACD,MAAO,EAAGC,OAAQ,IAIxBC,EA8KP,SAAoBC,GACnB,IAIIC,EACAC,EALEC,EAASH,EAAYG,OACrBC,EAAS,CAACJ,EAAYK,SACtBjB,EAAI,IAAIkB,MAAMH,GAAQI,KAAK,GAC7BC,EAAI,EAIR,KAAOA,EAAIL,GACLf,EAAEoB,GAAKA,GACZP,EAAIO,EAAI,GAAKpB,EAAEoB,GACfN,EAAIF,EAAYQ,GAChBR,EAAYQ,GAAKR,EAAYC,GAC7BD,EAAYC,GAAKC,IACfd,EAAEoB,GACJA,EAAI,EACJJ,EAAOrB,KAAKiB,EAAYK,WAExBjB,EAAEoB,GAAK,IACLA,GAGH,OAAOJ,EApMcK,CAAQd,GACvBe,EAAyB,GAG/BX,EAAalB,SAAQ,SAACmB,GAIrB,IAuBMW,EAvBc,SAAdC,EAAeC,EAAeC,GACnC,GAAID,GAASb,EAAYG,OACxB,MAAO,GAGR,IAAMY,EAAMf,EAAYa,GAKlBG,EAJqB,CAC1B,EAAI,EAAG,GAG6BvC,KAAI,SAACwC,GAAD,MAAc,CACtD5B,MAAO0B,EAAI1B,MACX6B,KAAMD,EACNE,UAAW,OAQZ,OAJIL,GACHA,EAAcjC,SAAQ,SAACuC,GAAD,OAAOA,EAAED,UAAYH,KAE5CJ,EAAYC,EAAQ,EAAGG,GAChBA,EAEUJ,CAAY,GACxBS,EAAW,SAAXA,EAAYC,EAAoBN,GACrC,IAAMO,EAAK,YAAOP,GAClBO,EAAMxC,KAAKuC,GACPA,EAASH,UAAUhB,OACtBmB,EAASH,UAAUtC,SAAQ,SAACuC,GAC3BC,EAASD,EAAGG,MAGbb,EAAU3B,KAAKwC,IAGjBZ,EAAU9B,SAAQ,SAACoC,GAAD,OAAOI,EAASJ,EAAG,UAGtCP,EAAU7B,SAAQ,SAAC2C,GAClB,IAAMC,EAAUC,EAAenC,EAAYiC,GAE3C5B,EAAU6B,EAAQ5B,OAAOA,MAAQD,EAAU6B,EAAQ5B,OAAOA,MAAQ,EAClED,EAAU6B,EAAQ3B,QAAQA,OAASF,EAAU6B,EAAQ3B,QAAQA,OAAS,KAGvE,IAAM6B,EAAc,SAACC,EAAmBC,EAAoBC,GAE3D,OAAQF,EAAYE,EAA0B,EAAbD,GAA+B,GAD/C,GAAKD,EAAYC,KAInC,OAAOE,OAAOC,KAAKpC,GAAWnB,KAAI,SAACwB,GAClC,IAAMgC,EAAOrC,EAAUK,GACjB2B,EAAYK,EAAKpC,MAAQa,EAAUP,OACnC0B,EAAaI,EAAKnC,OAASY,EAAUP,OAS3C,MAR6B,CAC5B+B,MAAOjC,EACPkC,eAAgBP,EAChBQ,gBAAiBP,EACjBQ,UAAWV,EAAYC,EAAWC,EAAY,GAC9CS,WAAYX,EAAYC,EAAWC,EAAY,GAC/CU,SAAUZ,EAAYC,EAAWC,EAAY,QAMnCH,EAAiB,SAACnC,EAAwBiD,GACtD,IAAMC,EAAyB,CAC9BnE,MAAM,YAAKiB,EAAWjB,MAAMG,KAAI,SAAC+C,GAAD,MAAQ,CAAC5C,OAAO,YAAK4C,EAAE5C,QAASI,OAAQwC,EAAExC,aAI3EwD,EAAS3D,SAAQ,SAAC6D,GACjBC,EAAcF,EAAYC,MAM3B,IAHA,IAAMjB,EAAmB,GAGhBD,EAAIiB,EAAWnE,MAAM6B,OAAS,EAAGqB,GAAK,EAAGA,IAEjD,IADA,IAAM7C,EAAO8D,EAAWnE,MAAMkD,GACrBpC,EAAIT,EAAKC,OAAOuB,OAAS,EAAGf,GAAK,EAAGA,IAE5C,GADAqC,EAAQ1C,KAAKJ,EAAKC,OAAOQ,IACF,IAAnBqC,EAAQtB,OACX,MAAO,CACNN,MAAO4B,EAAQ,GACf3B,OAAQ2B,EAAQ,IAKpB,MAAMxC,MAAM,oCAIA0D,EAAgB,SAACpD,EAAwBqD,GACrD,IAAMC,EAAYtD,EAAWjB,MAAMwE,WAAU,SAACtB,GAAD,OAAOA,EAAE5C,OAAOmE,QAAQH,EAAQvD,QAAU,KACjFV,EAAOY,EAAWjB,MAAMuE,GAGxBG,EAAYrE,EAAKC,OAAOqE,OAAOtE,EAAKC,OAAOmE,QAAQH,EAAQvD,QAE3D6D,EAAmB,SAACrC,GACzB,GAAIA,GAAStB,EAAWjB,MAAM6B,OAC7B,IAAK,IAAIK,EAAIjB,EAAWjB,MAAM6B,OAAS,EAAGK,EAAIK,EAAOL,IACpDjB,EAAWjB,MAAMS,KAAK,CAACH,OAAQ,MAK5BuE,EAAoB,SAACvE,EAAiBD,GAC3CC,EAAOC,SAAQ,SAACO,GACfT,EAAKC,OAAOG,KAAKK,OAIbgE,EAAmBP,EAAYD,EAAQ1B,KAG7CgC,EAAiBE,GAEjB,IAAMC,EAAkB9D,EAAWjB,MAAM8E,GACzC,GAA8B,WAA3BC,EAAgBrE,OAAoB,CACtC,IAAMsE,EAAqB/D,EAAWjB,MAAM8E,EAAmB,GAGzDG,EAAcD,EAAmB1E,OACvC0E,EAAmB1E,OAAS,GAE5BuE,EAAkBH,EAAWM,GAC7BH,EAAkBI,EAAaD,QAEzB,GAA8B,UAA3BD,EAAgBrE,OAAmB,CAC5C,IAAMwE,EAA0BJ,EAAmB,EACnDF,EAAiBM,GAGjBL,EAAkBH,EADSzD,EAAWjB,MAAMkF,SAI5CL,EAAkBH,EAAWK,IAIlBI,EAAuB,WAInC,IAHA,IAAM9D,EAAc,CAAC,CAACN,MAAM,OAAQ,CAACA,MAAM,SAAS,CAACA,MAAM,SAAS,CAACA,MAAM,QAAQ,CAACA,MAAM,WAEpFE,EAAyB,CAACjB,MAAM,CAAC,CAACM,OAAQ,IAAK,CAACA,OAAQ,IAAK,CAACA,OAAQ,MACtEe,EAAKQ,QAAQ,CAClB,IAAMyC,EAAUc,EAAc/D,GAC9BJ,EAAWjB,MAAMsE,EAAQ1B,KAAO,GAAGtC,OAAOG,KAAK6D,EAAQvD,OAExD,OAAOE,GAIKmE,EAAgB,SAAC/D,GAE7B,IAAMgE,EAAWC,KAAKC,MAAMD,KAAKE,SAAYnE,EAAKQ,QAC5CY,EAAMpB,EAAKsD,OAAOU,EAAU,GAAG,GAC/BI,EAAaH,KAAKC,MAAsB,EAAhBD,KAAKE,UAAgB,EAEnD,OAAO,2BAAI/C,GAAX,IAAgBG,KAAM6C,KCxGRC,MA5Gf,WAAe,MAGaC,mBAAiB,CACzCC,WAAY5E,EAAYmE,KACxBU,UAAW,UALA,mBAGNC,EAHM,KAGCC,EAHD,KAuCb,OACE,sBAAKC,UAAU,YAAf,UACE,+CACA,8KACA,sCACA,+BACE,8CACA,gDACA,gDACA,+CACA,iDACA,2CACA,6CAEF,uBAAMC,SAAU,SAACC,IA7CH,WAChB,IAAMjF,EAAanB,EAAWgG,EAAMF,YAC9BvE,EAAOT,EAAUkF,EAAMD,WACvBM,EAAU/E,EAAQH,EAAYI,GACpC0E,EAAS,2BAAID,GAAL,IAAYK,aAyCMC,GAAaF,EAAEG,kBAAvC,UACE,sBAAKL,UAAU,aAAf,UACE,uBAAOA,UAAU,aAAaM,QAAQ,aAAtC,yBACA,uBAAON,UAAU,eAAeO,KAAK,OAAOC,GAAG,aAAaC,WAAW,QAAQC,MAAOZ,EAAMF,WAAYe,SAAU,SAACT,GAAD,OAAOH,EAAS,2BAAID,GAAL,IAAYF,WAAYM,EAAEU,OAAOF,eAEpK,sBAAKV,UAAU,aAAf,UACE,uBAAOM,QAAQ,OAAf,6BACA,uBAAON,UAAU,eAAeO,KAAK,OAAOC,GAAG,OAAOC,WAAW,QAAQC,MAAOZ,EAAMD,UAAWc,SAAU,SAACT,GAAD,OAAOH,EAAS,2BAAID,GAAL,IAAYD,UAAWK,EAAEU,OAAOF,eAE5J,uBACA,uBAAOV,UAAU,kBAAkBO,KAAK,SAASG,MAAM,eACtDZ,EAAMK,SACL,yBAAQH,UAAU,cAAcW,SAlDjB,SAACT,GAEtB,IAAMW,EAAiBX,EAAEU,OAAOF,MAAMxG,MAAM,KACtCa,EAAQ8F,EAAe,GACvBvC,EAAmB,CACvBvD,MAAOA,EACP6B,KAAMkE,SAASD,EAAe,KAE1B5F,EAAanB,EAAWgG,EAAMF,YACpCvB,EAAcpD,EAAYqD,GAE1B,IAAIyC,EAAgBjB,EAAMD,UAAUmB,QAAQ9F,EAAYH,GAAQ,IAG5DgG,IACFA,EAAgB,QAChB9F,EAAWjB,MAAMO,SAAQ,SAAA2C,GAAC,OAAIA,EAAExC,YAASuG,MAG3C,IAAM5F,EAAOT,EAAUmG,GACjBZ,EAAU/E,EAAQH,EAAYI,GACpC0E,EAAS,CAACH,WAAY5E,EAAYC,GAAa4E,UAAWkB,EAAeZ,aA6BTO,MAAM,IAAIQ,MAAO,CAACC,UAAW,QAAvF,UACE,wBAAQC,UAAQ,EAACC,UAAQ,EAACX,MAAM,IAAhC,8BACC9F,EAAUkF,EAAMD,WAAW1F,KAAI,SAAAmH,GAAC,OAC/B,2BAAUC,MAAOD,EAAEvG,MAAnB,UACE,wBAAQ2F,MAAOY,EAAEvG,MAAQ,KAAzB,SAAgCuG,EAAEvG,MAAQ,OAC1C,wBAAQ2F,MAAOY,EAAEvG,MAAQ,KAAzB,SAAgCuG,EAAEvG,MAAQ,OAC1C,wBAAQ2F,MAAOY,EAAEvG,MAAQ,KAAzB,SAAgCuG,EAAEvG,MAAQ,mBAMpD,uBACC+E,EAAMK,SACL,wBAAOH,UAAU,uBAAjB,UACE,gCACE,+BACE,uCACA,4CACA,6CACA,2CACA,kDACA,wDAGJ,gCACGF,EAAMK,QAAQhG,KAAI,SAAA2C,GAAC,OAChB,+BACA,oBAAI0E,MAAM,MAAV,SAAiB1E,EAAEc,QACnB,8BAAMd,EAAEiB,UAAU0D,QAAQ,KAC1B,8BAAM3E,EAAEkB,WAAWyD,QAAQ,KAC3B,8BAAM3E,EAAEmB,SAASwD,QAAQ,KACzB,8BAAM3E,EAAEe,eAAe4D,QAAQ,KAC/B,8BAAM3E,EAAEgB,gBAAgB2D,QAAQ,OANvB3E,EAAEc,mBCxFZ8D,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,O,MCFdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.86e38cd9.chunk.js","sourcesContent":["// convert camel code into the camel state data model\r\n\r\nimport { CamelState, Color, Die, Hazard, Map, Tile } from \"./camel\";\r\n\r\nconst codeColorMap: Map<Color> = {\r\n    \"r\": \"Red\",\r\n    \"b\": \"Blue\",\r\n    \"g\": \"Green\",\r\n    \"y\": \"Yellow\",\r\n    \"w\": \"White\",\r\n};\r\nconst hazardCodeMap: Map<Hazard> = {\r\n    \"o\":\"Oasis\",\r\n    \"d\": \"Desert\"\r\n};\r\n\r\nexport const parseCamel = (camelCode: string): CamelState => {\r\n    const tiles = camelCode.toLowerCase().split(\",\").map(squareString => {\r\n        const tile:Tile = {camels: []};\r\n        squareString.split('').forEach(character => {\r\n            switch(character) {\r\n                case \"r\":\r\n                case \"b\":\r\n                case \"g\":\r\n                case \"y\":\r\n                case \"w\":\r\n                    tile.camels.push(codeColorMap[character]);\r\n                    break;\r\n                case \"o\":\r\n                case \"d\":\r\n                    tile.hazard = hazardCodeMap[character];\r\n                    break;\r\n                default:\r\n                    throw new Error(`Unsupported Character ${character} found in camel string`)\r\n            }\r\n        });\r\n        return tile;\r\n    });\r\n    return { tiles };\r\n};\r\n\r\nexport const parseDice = (diceCode: string): Die[] => {\r\n    return diceCode.split(\"\").map(c => ({ color: codeColorMap[c] }));\r\n};\r\n\r\nexport const toCamelCode = (camelState: CamelState): string => {\r\n    \r\n    return camelState.tiles.map(tile => {\r\n        if(tile.hazard){\r\n            switch(tile.hazard){\r\n                case 'Oasis':\r\n                    return 'o';\r\n                case 'Desert':\r\n                    return 'd';\r\n            }\r\n        }\r\n        return tile.camels.map(colorToCode).join('');\r\n    }).join(',');\r\n}\r\n\r\nexport const toDiceCode = (dice: Die[]) => {\r\n    return dice.map(d => colorToCode(d.color)).join('');\r\n};\r\n\r\nexport const colorToCode = (color: Color) => {\r\n    switch(color) {\r\n        case 'Red':\r\n            return 'r';\r\n        case 'Green':\r\n            return 'g';\r\n        case 'Blue': \r\n            return 'b';\r\n        case 'White':\r\n            return 'w';\r\n        case 'Yellow':\r\n            return 'y';\r\n    }\r\n};\r\n","\r\nexport type Color = 'Red' | 'Blue' | 'Green' | 'White' | 'Yellow';\r\nexport type Roll = 1 | 2 | 3;\r\nexport type Hazard = 'Desert' | 'Oasis';\r\n\r\n// tslint:disable: interface-name\r\nexport interface Camel {\r\n\tcolor: Color;\r\n}\r\n\r\nexport interface Tile {\r\n\tcamels: Color[];\r\n    hazard?: Hazard;\r\n}\r\n\r\nexport interface CamelState {\r\n\ttiles: Tile[];\r\n}\r\n\r\nexport interface CamelOdds {\r\n\tcamel: Color;\r\n\tfirstPlaceOdds: number;\r\n\tsecondPlaceOdds: number;\r\n\tfiveValue: number;\r\n\tthreeValue: number;\r\n\ttwoValue: number;\r\n}\r\n\r\nexport interface Die {\r\n\tcolor: Color;\r\n}\r\n\r\nexport interface DieRoll extends Die {\r\n\tRoll: Roll;\r\n}\r\n\r\nexport interface Map<T> {\r\n\t[K: string]: T;\r\n}\r\n\r\n// lets just calculate every outcome and get the odds of each\r\nexport const getOdds = (camelState: CamelState, dice: Die[]): CamelOdds[] => {\r\n\r\n\tconst camelWins: Map<{first: number, second: number}> = {\r\n\t\t'Red': {first: 0, second: 0},\r\n\t\t'Blue': {first: 0, second: 0},\r\n\t\t'Green': {first: 0, second: 0},\r\n\t\t'White': {first: 0, second: 0},\r\n\t\t'Yellow': {first: 0, second: 0},\r\n\t};\r\n\r\n\t// having all possible timelines in memory at once may be a burdon - look into streaming.\r\n\tconst permutations = permute(dice);\r\n\tconst timelines: DieRoll[][] = [];\r\n\r\n\t// populate all timelines\r\n\tpermutations.forEach((permutation) => {\r\n\t\tinterface RollNode extends DieRoll {\r\n\t\t\tnextRolls: RollNode[];\r\n\t\t}\r\n\t\tconst addDieRolls = (index: number, previousRolls?: RollNode[]) => {\r\n\t\t\tif (index >= permutation.length) {\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\r\n\t\t\tconst die = permutation[index];\r\n\t\t\tconst rollValues: Roll[] = [\r\n\t\t\t\t1 , 2, 3,\r\n\t\t\t];\r\n\t\t\t\r\n\t\t\tconst rolls: RollNode[] = rollValues.map((n: Roll) => ({\t\t\t\t\r\n\t\t\t\tcolor: die.color,\r\n\t\t\t\tRoll: n,\r\n\t\t\t\tnextRolls: [],\r\n\t\t\t}));\r\n\r\n\t\t\t// graph will use references fyi, hopefully wont be an issue\r\n\t\t\tif (previousRolls) { \r\n\t\t\t\tpreviousRolls.forEach((r) => r.nextRolls = rolls);\r\n\t\t\t}\r\n\t\t\taddDieRolls(index + 1, rolls);\r\n\t\t\treturn rolls;\r\n\t\t};\r\n\t\tconst rollGraph = addDieRolls(0);\r\n\t\tconst traverse = (rollNode: RollNode, rolls: DieRoll[]) => {\r\n\t\t\tconst clone = [...rolls];\r\n\t\t\tclone.push(rollNode);\r\n\t\t\tif (rollNode.nextRolls.length) {\r\n\t\t\t\trollNode.nextRolls.forEach((r) => {\r\n\t\t\t\t\ttraverse(r, clone);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\ttimelines.push(clone);\r\n\t\t\t}\r\n\t\t};\r\n\t\trollGraph.forEach((n) => traverse(n, []));\t\t\r\n\t});\r\n\r\n\ttimelines.forEach((t) => {\r\n\t\tconst winners = simulateWinner(camelState, t);\r\n\r\n\t\tcamelWins[winners.first].first = camelWins[winners.first].first + 1;\r\n\t\tcamelWins[winners.second].second = camelWins[winners.second].second + 1;\r\n\t});\r\n\r\n\tconst getBetValue = (firstOdds: number, secondOdds: number, betValue: number) => {\r\n\t\tconst loseOdds = 1 - (firstOdds + secondOdds);\r\n\t\treturn (firstOdds * betValue) + (secondOdds * 1) + (loseOdds * -1);\r\n\t};\r\n\r\n\treturn Object.keys(camelWins).map((k) => {\r\n\t\tconst wins = camelWins[k];\r\n\t\tconst firstOdds = wins.first / timelines.length;\r\n\t\tconst secondOdds = wins.second / timelines.length;\r\n\t\tconst camelOdds: CamelOdds = {\r\n\t\t\tcamel: k as Color,\r\n\t\t\tfirstPlaceOdds: firstOdds,\r\n\t\t\tsecondPlaceOdds: secondOdds,\r\n\t\t\tfiveValue: getBetValue(firstOdds, secondOdds, 5),\r\n\t\t\tthreeValue: getBetValue(firstOdds, secondOdds, 3),\r\n\t\t\ttwoValue: getBetValue(firstOdds, secondOdds, 2),\r\n\t\t} ;\r\n\t\treturn camelOdds;\r\n\t});\r\n};\r\n\r\nexport const simulateWinner = (camelState: CamelState, timeLine: DieRoll[]): {first: Color, second: Color }  => {\r\n\tconst cloneState: CamelState = {\r\n\t\ttiles: [...camelState.tiles.map((t) => ({camels: [...t.camels], hazard: t.hazard}))],\r\n\t};\r\n\r\n\t// update the state after each die roll in the timeline\r\n\ttimeLine.forEach((roll) => {\r\n\t\tmoveCamelUnit(cloneState, roll);\r\n\t});\r\n\r\n\tconst winners: Color[] = [];\r\n\r\n\t// get the end of round first and second place camel\r\n\tfor (let t = cloneState.tiles.length - 1; t >= 0; t--) {\r\n\t\tconst tile = cloneState.tiles[t];\r\n\t\tfor (let c = tile.camels.length - 1; c >= 0; c--) {\r\n\t\t\twinners.push(tile.camels[c]);\r\n\t\t\tif (winners.length === 2) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tfirst: winners[0], \r\n\t\t\t\t\tsecond: winners[1],\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tthrow Error('this code should not be reached');\r\n};\r\n\r\n// update the camel state based on the DieRoll\r\nexport const moveCamelUnit = (camelState: CamelState, dieRoll: DieRoll): void => {\r\n\tconst tileIndex = camelState.tiles.findIndex((t) => t.camels.indexOf(dieRoll.color) > -1);\r\n\tconst tile = camelState.tiles[tileIndex];\r\n\r\n\t// getting and removing the camel unit\r\n\tconst camelUnit = tile.camels.splice(tile.camels.indexOf(dieRoll.color));\r\n\r\n\tconst ensureTileExists = (index: number) => {\r\n\t\tif (index >= camelState.tiles.length) {\r\n\t\t\tfor (let i = camelState.tiles.length - 1; i < index; i++) {\r\n\t\t\t\tcamelState.tiles.push({camels: []});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconst placeCamelsAtTile = (camels: Color[], tile: Tile) => {\r\n\t\tcamels.forEach((c) => {\r\n\t\t\ttile.camels.push(c);\r\n\t\t});\r\n\t}\r\n\r\n\tconst destinationIndex = tileIndex + dieRoll.Roll;\r\n\r\n\t// make sure that tiles in front exist in the array\r\n\tensureTileExists(destinationIndex)\r\n\r\n\tconst destinationTile = camelState.tiles[destinationIndex];\r\n\tif(destinationTile.hazard === 'Desert'){\r\n\t\tconst specialDestination = camelState.tiles[destinationIndex - 1];\r\n\r\n\t\t// make sure that the moving camel unit is placed under the other camels\r\n\t\tconst otherCamels = specialDestination.camels;\r\n\t\tspecialDestination.camels = [];\r\n\t\t\r\n\t\tplaceCamelsAtTile(camelUnit, specialDestination);\r\n\t\tplaceCamelsAtTile(otherCamels, specialDestination);\r\n\r\n\t} else if(destinationTile.hazard === 'Oasis'){\r\n\t\tconst specialDestinationIndex = destinationIndex + 1;\r\n\t\tensureTileExists(specialDestinationIndex);\r\n\t\t\r\n\t\tconst specialDestination = camelState.tiles[specialDestinationIndex];\r\n\t\tplaceCamelsAtTile(camelUnit, specialDestination);\r\n\r\n\t} else {\r\n\t\tplaceCamelsAtTile(camelUnit, destinationTile);\r\n\t}\r\n};\r\n\r\nexport const generateInitialState = (): CamelState => {\r\n\tconst dice: Die[] = [{color:'Red'}, {color:'Green'},{color:'White'},{color:'Blue'},{color:'Yellow'}];\r\n\r\n\tconst camelState: CamelState = {tiles:[{camels: []}, {camels: []}, {camels: []}]};\r\n\twhile(dice.length) {\r\n\t\tconst dieRoll = getRandomRoll(dice);\r\n\t\tcamelState.tiles[dieRoll.Roll - 1].camels.push(dieRoll.color);\r\n\t}\r\n\treturn camelState;\r\n};\r\n\r\n// note: this will actually modify the dice array in the parameter\r\nexport const getRandomRoll = (dice: Die[]): DieRoll => {\r\n\r\n\tconst dieIndex = Math.floor(Math.random() * (dice.length));\r\n\tconst die = dice.splice(dieIndex, 1)[0];\r\n\tconst rollNumber = Math.floor(Math.random() * 3) + 1\r\n\r\n\treturn {...die, Roll: rollNumber as Roll};\r\n};\r\n\r\n// creates returns every possible permutation of an array\r\nfunction permute<T>(permutation: T[]): T[][] {\r\n\tconst length = permutation.length;\r\n\tconst result = [permutation.slice()];\r\n\tconst c = new Array(length).fill(0);\r\n\tlet i = 1;\r\n\tlet k;\r\n\tlet p;\r\n  \r\n\twhile (i < length) {\r\n\t  if (c[i] < i) {\r\n\t\tk = i % 2 && c[i];\r\n\t\tp = permutation[i];\r\n\t\tpermutation[i] = permutation[k];\r\n\t\tpermutation[k] = p;\r\n\t\t++c[i];\r\n\t\ti = 1;\r\n\t\tresult.push(permutation.slice());\r\n\t  } else {\r\n\t\tc[i] = 0;\r\n\t\t++i;\r\n\t  }\r\n\t}\r\n\treturn result;\r\n  }\r\n","import React, { useState } from 'react';\r\nimport './App.css';\r\nimport { colorToCode, parseCamel, parseDice, toCamelCode } from './camel-parser'\r\nimport { CamelOdds, Color, DieRoll, generateInitialState, getOdds, moveCamelUnit, Roll } from './camel'\r\n\r\ninterface IState {\r\n  boardInput: string;\r\n  diceInput: string;\r\n  results?: CamelOdds[];\r\n}\r\nfunction App() {\r\n\r\n  // create a random initial state will all dice remaining\r\n  const [state, setState] = useState<IState>({ \r\n    boardInput: toCamelCode(generateInitialState()), \r\n    diceInput: \"rgbyw\" \r\n  });\r\n\r\n  const calculate = () => {\r\n    const camelState = parseCamel(state.boardInput);\r\n    const dice = parseDice(state.diceInput);\r\n    const results = getOdds(camelState, dice);\r\n    setState({...state, results})\r\n  };\r\n\r\n  const selectNextRoll = (e: any) => {\r\n    // option format is Color_Roll e.g. Red_1\r\n    const selectedOption = e.target.value.split('_');\r\n    const color = selectedOption[0] as Color;\r\n    const dieRoll: DieRoll = {\r\n      color: color,\r\n      Roll: parseInt(selectedOption[1]) as Roll,\r\n    }\r\n    const camelState = parseCamel(state.boardInput);\r\n    moveCamelUnit(camelState, dieRoll);\r\n\r\n    let remainingDice = state.diceInput.replace(colorToCode(color), '');\r\n    \r\n    // if there are no remaining dice. Move to next round and clear the board;\r\n    if(!remainingDice){\r\n      remainingDice = 'rwgby';\r\n      camelState.tiles.forEach(t => t.hazard = undefined);\r\n    }\r\n\r\n    const dice = parseDice(remainingDice);\r\n    const results = getOdds(camelState, dice);\r\n    setState({boardInput: toCamelCode(camelState), diceInput: remainingDice, results})\r\n  };\r\n\r\n  return (\r\n    <div className=\"container\">\r\n      <h1>Cameluculator</h1>\r\n      <p>Enter a game state using camel code. Separate spaces with a \",\". Camels stack so that the right most camel will be on top. Example: rw,,o,gby</p>\r\n      <h3>Key:</h3>\r\n      <ul>\r\n        <li>r: Red Camel</li>\r\n        <li>g: Green Camel</li>\r\n        <li>w: White Camel</li>\r\n        <li>b: Blue Camel</li>\r\n        <li>y: Yellow Camel</li>\r\n        <li>d: Desert</li>\r\n        <li>o: Oasis</li>\r\n      </ul>\r\n      <form onSubmit={(e) => {calculate(); e.preventDefault();}}>\r\n        <div className=\"form-group\">\r\n          <label className=\"form-label\" htmlFor=\"camel-code\">Camel Code </label>\r\n          <input className=\"form-control\" type=\"text\" id=\"camel-code\" spellCheck=\"false\" value={state.boardInput} onChange={(e) => setState({...state, boardInput: e.target.value})} />\r\n        </div>\r\n        <div className=\"form-group\">  \r\n          <label htmlFor=\"dice\">Remaining Dice </label>\r\n          <input className=\"form-control\" type=\"text\" id=\"dice\" spellCheck=\"false\" value={state.diceInput} onChange={(e) => setState({...state, diceInput: e.target.value})} /> \r\n        </div>\r\n        <br />\r\n        <input className=\"btn btn-primary\" type=\"submit\" value=\"Calculate!\"/>\r\n        {state.results && \r\n          <select className=\"form-select\" onChange={selectNextRoll} value='_' style={{marginTop: '10px'}}>\r\n            <option selected disabled value='_'>Select Next Roll</option>\r\n            {parseDice(state.diceInput).map(d =>\r\n              <optgroup label={d.color}>\r\n                <option value={d.color + '_1'}>{d.color + ' 1'}</option>\r\n                <option value={d.color + '_2'}>{d.color + ' 2'}</option>\r\n                <option value={d.color + '_3'}>{d.color + ' 3'}</option>\r\n              </optgroup>\r\n            )}\r\n          </select>\r\n        }\r\n      </form>\r\n      <br />\r\n      {state.results &&\r\n        <table className=\"table table-bordered\">\r\n          <thead>\r\n            <tr>\r\n              <th>Camel</th>\r\n              <th>Five Value</th>\r\n              <th>Three Value</th>\r\n              <th>Two Value</th>\r\n              <th>First Place Odds</th>\r\n              <th>Second Place Odds</th>\r\n            </tr>\r\n          </thead>\r\n          <tbody>\r\n            {state.results.map(r => \r\n                <tr key={r.camel}>\r\n                <th scope=\"row\">{r.camel}</th>\r\n                <td>{+r.fiveValue.toFixed(3)}</td>\r\n                <td>{+r.threeValue.toFixed(3)}</td>\r\n                <td>{+r.twoValue.toFixed(3)}</td>\r\n                <td>{+r.firstPlaceOdds.toFixed(3)}</td>\r\n                <td>{+r.secondPlaceOdds.toFixed(3)}</td>\r\n              </tr>\r\n            )}\r\n          </tbody>\r\n        </table>\r\n      }\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);  \r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n}\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport 'bootstrap/dist/css/bootstrap.css';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}