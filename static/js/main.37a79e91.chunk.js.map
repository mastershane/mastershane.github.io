{"version":3,"sources":["camel-parser.ts","camel.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["codeColorMap","hazardCodeMap","getOdds","camelState","dice","camelWins","first","second","permutations","permutation","k","p","length","result","slice","c","Array","fill","i","push","permute","timelines","forEach","rollGraph","addDieRolls","index","previousRolls","die","rolls","map","n","color","Roll","nextRolls","r","traverse","rollNode","clone","t","winners","simulateWinner","getBetValue","firstOdds","secondOdds","betValue","Object","keys","wins","camel","firstPlaceOdds","secondPlaceOdds","fiveValue","threeValue","twoValue","timeLine","tiles","camels","hazard","roll","dieRoll","tileIndex","findIndex","indexOf","tile","camelUnit","splice","destinationIndex","destinationTile","specialDestination","otherCamels","specialDestinationIndex","moveCamelUnit","Error","App","useState","boardInput","diceInput","state","setState","calculate","split","squareString","character","results","className","onSubmit","e","preventDefault","htmlFor","type","id","spellCheck","value","onChange","target","scope","toFixed","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.37a79e91.chunk.js","sourcesContent":["// convert camel code into the camel state data model\r\n\r\nimport { CamelState, Color, Die, Hazard, Map, Tile } from \"./camel\";\r\n\r\nconst codeColorMap: Map<Color> = {\r\n    \"r\": \"Red\",\r\n    \"b\": \"Blue\",\r\n    \"g\": \"Green\",\r\n    \"y\": \"Yellow\",\r\n    \"w\": \"White\",\r\n};\r\nconst hazardCodeMap: Map<Hazard> = {\r\n    \"o\":\"Oasis\",\r\n    \"d\": \"Desert\"\r\n};\r\n\r\nexport const parseCamel = (camelCode: string): CamelState => {\r\n    const tiles = camelCode.split(\",\").map(squareString => {\r\n        const tile:Tile = {camels: []};\r\n        squareString.split('').forEach(character => {\r\n            switch(character) {\r\n                case \"r\":\r\n                case \"b\":\r\n                case \"g\":\r\n                case \"y\":\r\n                case \"w\":\r\n                    tile.camels.push(codeColorMap[character]);\r\n                    break;\r\n                case \"o\":\r\n                case \"d\":\r\n                    tile.hazard = hazardCodeMap[character];\r\n                    break;\r\n                default:\r\n                    throw new Error(`Unsupported Character ${character} found in camel string`)\r\n            }\r\n        });\r\n        return tile;\r\n    });\r\n    return { tiles };\r\n};\r\n\r\nexport const parseDice = (diceCode: string): Die[] => {\r\n    return diceCode.split(\"\").map(c => ({ color: codeColorMap[c] }));\r\n};\r\n","\r\nexport type Color = 'Red' | 'Blue' | 'Green' | 'White' | 'Yellow';\r\nexport type Roll = 1 | 2 | 3;\r\nexport type Hazard = 'Desert' | 'Oasis';\r\n\r\n// tslint:disable: interface-name\r\nexport interface Camel {\r\n\tcolor: Color;\r\n}\r\n\r\nexport interface Tile {\r\n\tcamels: Color[];\r\n    hazard?: Hazard;\r\n}\r\n\r\nexport interface CamelState {\r\n\ttiles: Tile[];\r\n}\r\n\r\nexport interface CamelOdds {\r\n\tcamel: Color;\r\n\tfirstPlaceOdds: number;\r\n\tsecondPlaceOdds: number;\r\n\tfiveValue: number;\r\n\tthreeValue: number;\r\n\ttwoValue: number;\r\n}\r\n\r\nexport interface Die {\r\n\tcolor: Color;\r\n}\r\n\r\nexport interface DieRoll extends Die {\r\n\tRoll: Roll;\r\n}\r\n\r\nexport interface Map<T> {\r\n\t[K: string]: T;\r\n}\r\n\r\n// lets just calculate every outcome and get the odds of each\r\nexport const getOdds = (camelState: CamelState, dice: Die[]): CamelOdds[] => {\r\n\r\n\tconst camelWins: Map<{first: number, second: number}> = {\r\n\t\t'Red': {first: 0, second: 0},\r\n\t\t'Blue': {first: 0, second: 0},\r\n\t\t'Green': {first: 0, second: 0},\r\n\t\t'White': {first: 0, second: 0},\r\n\t\t'Yellow': {first: 0, second: 0},\r\n\t};\r\n\r\n\t// having all possible timelines in memory at once may be a burdon - look into streaming.\r\n\tconst permutations = permute(dice);\r\n\tconst timelines: DieRoll[][] = [];\r\n\r\n\t// populate all timelines\r\n\tpermutations.forEach((permutation) => {\r\n\t\tinterface RollNode extends DieRoll {\r\n\t\t\tnextRolls: RollNode[];\r\n\t\t}\r\n\t\tconst addDieRolls = (index: number, previousRolls?: RollNode[]) => {\r\n\t\t\tif (index >= permutation.length) {\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\r\n\t\t\tconst die = permutation[index];\r\n\t\t\tconst rollValues: Roll[] = [\r\n\t\t\t\t1 , 2, 3,\r\n\t\t\t];\r\n\t\t\t\r\n\t\t\tconst rolls: RollNode[] = rollValues.map((n: Roll) => ({\t\t\t\t\r\n\t\t\t\tcolor: die.color,\r\n\t\t\t\tRoll: n,\r\n\t\t\t\tnextRolls: [],\r\n\t\t\t}));\r\n\r\n\t\t\t// graph will use references fyi, hopefully wont be an issue\r\n\t\t\tif (previousRolls) { \r\n\t\t\t\tpreviousRolls.forEach((r) => r.nextRolls = rolls);\r\n\t\t\t}\r\n\t\t\taddDieRolls(index + 1, rolls);\r\n\t\t\treturn rolls;\r\n\t\t};\r\n\t\tconst rollGraph = addDieRolls(0);\r\n\t\tconst traverse = (rollNode: RollNode, rolls: DieRoll[]) => {\r\n\t\t\tconst clone = [...rolls];\r\n\t\t\tclone.push(rollNode);\r\n\t\t\tif (rollNode.nextRolls.length) {\r\n\t\t\t\trollNode.nextRolls.forEach((r) => {\r\n\t\t\t\t\ttraverse(r, clone);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\ttimelines.push(clone);\r\n\t\t\t}\r\n\t\t};\r\n\t\trollGraph.forEach((n) => traverse(n, []));\t\t\r\n\t});\r\n\r\n\ttimelines.forEach((t) => {\r\n\t\tconst winners = simulateWinner(camelState, t);\r\n\r\n\t\tcamelWins[winners.first].first = camelWins[winners.first].first + 1;\r\n\t\tcamelWins[winners.second].second = camelWins[winners.second].second + 1;\r\n\t});\r\n\r\n\tconst getBetValue = (firstOdds: number, secondOdds: number, betValue: number) => {\r\n\t\tconst loseOdds = 1 - (firstOdds + secondOdds);\r\n\t\treturn (firstOdds * betValue) + (secondOdds * 1) + (loseOdds * -1);\r\n\t};\r\n\r\n\treturn Object.keys(camelWins).map((k) => {\r\n\t\tconst wins = camelWins[k];\r\n\t\tconst firstOdds = wins.first / timelines.length;\r\n\t\tconst secondOdds = wins.second / timelines.length;\r\n\t\tconst camelOdds: CamelOdds = {\r\n\t\t\tcamel: k as Color,\r\n\t\t\tfirstPlaceOdds: firstOdds,\r\n\t\t\tsecondPlaceOdds: secondOdds,\r\n\t\t\tfiveValue: getBetValue(firstOdds, secondOdds, 5),\r\n\t\t\tthreeValue: getBetValue(firstOdds, secondOdds, 3),\r\n\t\t\ttwoValue: getBetValue(firstOdds, secondOdds, 2),\r\n\t\t} ;\r\n\t\treturn camelOdds;\r\n\t});\r\n};\r\n\r\n// need to account for deserts and stuff like that on the camel state\r\nexport const simulateWinner = (camelState: CamelState, timeLine: DieRoll[]): {first: Color, second: Color }  => {\r\n\tconst clone: CamelState = {\r\n\t\ttiles: [...camelState.tiles.map((t) => ({camels: [...t.camels], hazard: t.hazard}))],\r\n\t};\r\n\r\n\tconst moveCamelUnit = (dieRoll: DieRoll) => {\r\n\t\tconst tileIndex = clone.tiles.findIndex((t) => t.camels.indexOf(dieRoll.color) > -1);\r\n\t\tconst tile = clone.tiles[tileIndex];\r\n\r\n\t\t// getting and removing the camel unit\r\n\t\tconst camelUnit = tile.camels.splice(tile.camels.indexOf(dieRoll.color));\r\n\r\n\t\tconst destinationIndex = tileIndex + dieRoll.Roll;\r\n\r\n\t\t// making sure that tiles in front exist in the array\r\n\t\tif (destinationIndex >= clone.tiles.length) {\r\n\t\t\tfor (let i = clone.tiles.length - 1; i < destinationIndex; i++) {\r\n\t\t\t\tclone.tiles.push({camels: []});\r\n\t\t\t}\r\n\t\t}\r\n\r\n        const destinationTile = clone.tiles[destinationIndex];\r\n        if(destinationTile.hazard === 'Desert'){\r\n            const specialDestination = clone.tiles[destinationIndex - 1];\r\n\r\n            const otherCamels = specialDestination.camels;\r\n            specialDestination.camels = [];\r\n            camelUnit.forEach((c) => {\r\n                specialDestination.camels.push(c);\r\n            });\r\n            otherCamels.forEach((c) => {\r\n                specialDestination.camels.push(c);\r\n            });\r\n\r\n        } else if(destinationTile.hazard === 'Oasis'){\r\n            const specialDestinationIndex = destinationIndex + 1;\r\n            const specialDestination = clone.tiles[specialDestinationIndex];\r\n            \r\n            if (specialDestinationIndex + 1 >= clone.tiles.length) {\r\n                for (let i = clone.tiles.length - 1; i < specialDestinationIndex; i++) {\r\n                    clone.tiles.push({camels: []});\r\n                }\r\n            }\r\n\r\n            camelUnit.forEach((c) => {\r\n                specialDestination.camels.push(c);\r\n            });\t\r\n\r\n        } else {\r\n            // move each camel in the unit (preserving vertical order)\r\n            camelUnit.forEach((c) => {\r\n                destinationTile.camels.push(c);\r\n            });\t\r\n        }\t\r\n\t};\r\n\r\n\ttimeLine.forEach((roll) => {\r\n\t\tmoveCamelUnit(roll);\r\n\t});\r\n\r\n\tconst winners: Color[] = [];\r\n\r\n\tfor (let t = clone.tiles.length - 1; t >= 0; t--) {\r\n\t\tconst tile = clone.tiles[t];\r\n\t\tfor (let c = tile.camels.length - 1; c >= 0; c--) {\r\n\t\t\twinners.push(tile.camels[c]);\r\n\t\t\tif (winners.length === 2) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tfirst: winners[0], \r\n\t\t\t\t\tsecond: winners[1],\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tthrow Error('this code should not be reached');\r\n};\r\n\r\nfunction permute<T>(permutation: T[]) {\r\n\tconst length = permutation.length;\r\n\tconst result = [permutation.slice()];\r\n\tconst c = new Array(length).fill(0);\r\n\tlet i = 1;\r\n\tlet k;\r\n\tlet p;\r\n  \r\n\twhile (i < length) {\r\n\t  if (c[i] < i) {\r\n\t\tk = i % 2 && c[i];\r\n\t\tp = permutation[i];\r\n\t\tpermutation[i] = permutation[k];\r\n\t\tpermutation[k] = p;\r\n\t\t++c[i];\r\n\t\ti = 1;\r\n\t\tresult.push(permutation.slice());\r\n\t  } else {\r\n\t\tc[i] = 0;\r\n\t\t++i;\r\n\t  }\r\n\t}\r\n\treturn result;\r\n  }\r\n","import React, { useState } from 'react';\r\nimport './App.css';\r\nimport { parseCamel, parseDice } from './camel-parser'\r\nimport { CamelOdds, getOdds } from './camel'\r\n\r\ninterface IState {\r\n  boardInput: string;\r\n  diceInput: string;\r\n  results?: CamelOdds[];\r\n}\r\nfunction App() {\r\n\r\n  const [state, setState] = useState<IState>({ boardInput: \"\", diceInput: \"rgbyw\" });\r\n\r\n  const calculate = () => {\r\n    const camelState = parseCamel(state.boardInput);\r\n    const dice = parseDice(state.diceInput);\r\n    const results = getOdds(camelState, dice);\r\n    setState({...state, results})\r\n  }\r\n\r\n  return (\r\n    <div className=\"container\">\r\n      <h1>Cameluculator</h1>\r\n      <p>Enter a game state using camel code. Separate spaces with a \",\". Camels stack so that the right most camel will be on top. Example: rw,,o,gby</p>\r\n      <h3>Key:</h3>\r\n      <ul>\r\n        <li>r: Red Camel</li>\r\n        <li>g: Green Camel</li>\r\n        <li>w: White Camel</li>\r\n        <li>b: Blue Camel</li>\r\n        <li>y: Yellow Camel</li>\r\n        <li>d: Desert</li>\r\n        <li>o: Oasis</li>\r\n      </ul>\r\n      <form onSubmit={(e) => {calculate(); e.preventDefault();}}>\r\n        <div className=\"form-group\">\r\n          <label className=\"form-label\" htmlFor=\"camel-code\">Camel Code </label>\r\n          <input className=\"form-control\" type=\"text\" id=\"camel-code\" spellCheck=\"false\" value={state.boardInput} onChange={(e) => setState({...state, boardInput: e.target.value})} />\r\n        </div>\r\n        <div className=\"form-group\">  \r\n          <label htmlFor=\"dice\">Remaining Dice </label>\r\n          <input className=\"form-control\" type=\"text\" id=\"dice\" spellCheck=\"false\" value={state.diceInput} onChange={(e) => setState({...state, diceInput: e.target.value})} /> \r\n        </div>\r\n        <br />\r\n        <input className=\"btn btn-primary\" type=\"submit\" value=\"Calculate!\"/>\r\n      </form>\r\n      <br />\r\n      {state.results &&\r\n        <table className=\"table table-bordered\">\r\n          <tr>\r\n            <th>Camel</th>\r\n            <th>Five Value</th>\r\n            <th>Three Value</th>\r\n            <th>Two Value</th>\r\n            <th>First Place Odds</th>\r\n            <th>Second Place Odds</th>\r\n          </tr>\r\n          {state.results.map(r => \r\n              <tr key={r.camel}>\r\n              <th scope=\"row\">{r.camel}</th>\r\n              <td>{r.fiveValue.toFixed(3)}</td>\r\n              <td>{r.threeValue.toFixed(3)}</td>\r\n              <td>{r.twoValue.toFixed(3)}</td>\r\n              <td>{r.firstPlaceOdds.toFixed(3)}</td>\r\n              <td>{r.secondPlaceOdds.toFixed(3)}</td>\r\n            </tr>\r\n          )}\r\n        </table>\r\n      }\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);  \r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n}\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport 'bootstrap/dist/css/bootstrap.css';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}